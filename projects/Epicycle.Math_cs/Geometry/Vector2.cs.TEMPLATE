[%#

def generate_dotnet_types_config():
    sint_types = ['sbyte', 'short', 'int', 'long']
    float_types = ['float', 'double' ]

    identity = lambda x: x
    cast = lambda t: lambda x: "((%s)%s)" % (t, x)
    round = lambda t: lambda x: "((%s)Math.Round(%s))" % (t, x)
    
    all_types = sint_types + float_types
    
    types = {}
    for t in all_types:
        types[t] = {}
        types[t]['name'] = t
        types[t]['size'] = {'sbyte': 1, 'short': 2, 'int': 4, 'long': 8, 'float': 4, 'double': 8}[t]
        types[t]['suffix'] = {'sbyte': 'b', 'short': 's', 'int': 'i', 'long': 'L', 'float': 'f', 'double': '', 'decimal': 'm'}[t]
        
        if t in sint_types:
            category = "sint"
        elif t in float_types:
            category = "float"
        
        types[t]['category'] = category
        
    for to_type in all_types:
        conv_config = {}
    
        for from_type in all_types:
            conv_from_config = {}
        
            from_category = types[from_type]['category']
            to_category = types[to_type]['category']
            
            conv = identity
            convr = identity

            if from_category == to_category:
                is_implicit = types[from_type]['size'] <= types[to_type]['size']
                conv = identity if is_implicit else cast(to_type)
                convr = conv
            elif from_category == "sint" and to_category == "float":
                is_implicit = True
            elif from_category == "float" and to_category == "sint":
                is_implicit = False
                conv = cast(to_type)
                convr = round(to_type) 
            
            conv_from_config['conv_op_type'] = ("implicit" if is_implicit else "explicit") if from_type != to_type else "none"
            conv_from_config['conv'] = conv
            conv_from_config['convr'] = convr
            conv_from_config['is_implicit'] = is_implicit
            
            conv_config[from_type] = conv_from_config
            
        types[to_type]['conv'] = conv_config
        
    return types
    
def generate_types_config(supported_types, dotnet_types_config):
    types_config = {}
    for type in supported_types:
        config = Params()

        dotnet_type_config = dotnet_types_config[type]
        
        config.type_config = dotnet_type_config
        config.name = "Vector2%s" % dotnet_type_config['suffix']
        config.size = dotnet_type_config['size'] * 2
        config.isClass = config.size > 16
        
        config.convFrom = {}
        config.convrFrom = {}
        config.convOpType = {}
        
        for from_type in supported_types:
            config.convFrom[from_type] = dotnet_type_config['conv'][from_type]['conv']
            config.convrFrom[from_type] = dotnet_type_config['conv'][from_type]['convr']
            config.convOpType[from_type] = dotnet_type_config['conv'][from_type]['conv_op_type']
        
        config.normalizedSupport = dotnet_type_config['category'] == "float"
        
        types_config[type] = config
        
    return types_config

dotnet_types_config = generate_dotnet_types_config()    

_.types = ['int', 'long', 'float', 'double']
_.typesConfig = generate_types_config(_.types, dotnet_types_config)
_.config = _.typesConfig[_.T]
_.name = _.config.name
_.classOrStruct = "class" if _.config.isClass else "struct"

#%]

public [#classOrStruct#] [#name#] : IEquatable<[#name#]>
{
    public [#T#] X 
    {
        get { return _x; }
    }

    public [#T#] Y 
    {
        get { return _y; }
    }
    
    private readonly [#T#] _x;
    private readonly [#T#] _y;

    public enum Axis
    {
        X = 0,
        Y = 1,
        Count = 2 // used in for loops
    }

    public [#T#] this[Axis axis]
    {
        get
        {
            switch (axis)
            {
                case Axis.X:
                    return _x;

                case Axis.Y:
                    return _y;

                default:
                    throw new IndexOutOfRangeException("Invalid 2D axis " + axis.ToString());
            }
        }
    }

    #region creation

    public [#name#]([#T#] x, [#T#] y)
    {
        _x = x;
        _y = y;
    }
    
[*# _.types ::
    public [#name#]([=# _.typesConfig[_item_].name #=] v)
    {
        _x = [=# _.config.convrFrom[_item_]("v.X") #=];
        _y = [=# _.config.convrFrom[_item_]("v.Y") #=];
    }
#*]

    public [#name#](OVector v)
    {
        ArgAssert.Equal(v.Dimension, "v.Dimension", 2, "2");

        _x = [=# _.config.convrFrom['double']("v[0]") #=];
        _y = [=# _.config.convrFrom['double']("v[1]") #=];
    }
    
[*# _.types ::
[?# _.config.convOpType[_item_] != "none" :?
    public static [=# _.config.convOpType[_item_] #=] operator [#name#]([=# _.typesConfig[_item_].name #=] v)
    {
        return new [#name#](v);
    }
#?]
#*]

    public static explicit operator [#name#](OVector v)
    {
        return new [#name#](v);
    }

    public static explicit operator OVector([#name#] v)
    {
        return new Vector(v._x, v._y);
    }
    
    #endregion

    #region equality

    public bool Equals([#name#] v)
    {
        return X == v.X && Y == v.Y;
    }

    public override bool Equals(object obj)
    {
        var v = obj as [#name#]?;

        if(!v.HasValue)
        {
            return false;
        }

        return Equals(v.Value);
    }

    public override int GetHashCode()
    {
        return X.GetHashCode() ^ Y.GetHashCode();
    }
    
    public static bool operator ==([#name#] v, [#name#] w)
    {
        return v.Equals(w);
    }

    public static bool operator !=([#name#] v, [#name#] w)
    {
        return !v.Equals(w);
    }

    #endregion

    #region norm

    public [#T#] Norm2
    {
        get { return _x * _x + _y * _y; }
    }
    
    public double Norm
    {
        get { return Math.Sqrt(Norm2); }
    }

    public static [#T#] Distance2([#name#] v, [#name#] w)
    {
        return (v - w).Norm2;
    }
    
    public static double Distance([#name#] v, [#name#] w)
    {
        return (v - w).Norm;
    }
    
[?#  _.config.normalizedSupport :?
    public [#name#] Normalized
    {
        get
        {
            var norm = this.Norm;

            if (norm < BasicMath.Epsilon)
            {
                return UnitX;
            }

            return this / [=# _.config.convrFrom['double']("norm") #=];
        }
    }
#?]

    #endregion

    #region algebra

    public static [#name#] operator +([#name#] v)
    {
        return v;
    }

    public static [#name#] operator -([#name#] v)
    {
        return new [#name#](-v._x, -v._y);
    }

    public static [#name#] operator *([#name#] v, [#T#] a)
    {
        return new [#name#](v._x * a, v._y * a);
    }

    public static [#name#] operator *([#T#] a, [#name#] v)
    {
        return v * a;
    }

    public static [#name#] operator /([#name#] v, [#T#] a)
    {
        return new [#name#](v._x / a, v._y / a);
    }

    public static [#name#] operator +([#name#] v, [#name#] w)
    {
        return new [#name#](v._x + w._x, v._y + w._y);
    }

    public static [#name#] operator -([#name#] v, [#name#] w)
    {
        return new [#name#](v._x - w._x, v._y - w._y);
    }

    public static [#T#] operator *([#name#] v, [#name#] w)
    {
        return v._x * w._x + v._y * w._y;
    }

    public [#T#] Cross([#name#] v)
    {
        return _x * v._y - _y * v._x;
    }
    
    public static [#name#] Mul([#name#] v, [#name#] w)
    {
        return new [#name#](v.X * w.X, v.Y * w.Y);
    }

    #endregion

    #region static

    public static readonly [#name#] Zero = new [#name#](0, 0);
    public static readonly [#name#] UnitX = new [#name#](1, 0);
    public static readonly [#name#] UnitY = new [#name#](0, 1);

    public static [#name#] Unit(Axis axis)
    {
        switch (axis)
        {
            case Axis.X:
                return UnitX;

            case Axis.Y:
                return UnitY;

            default:
                throw new IndexOutOfRangeException("Invalid 2D axis " + axis.ToString());
        }
    }

    public static double Angle([#name#] v, [#name#] w)
    {
        var vwcos = v * w;
        var vwsin = v.Cross(w);

        return Math.Atan2(vwsin, vwcos);
    }

    #endregion

    public override string ToString()
    {
        return string.Format("({0}, {1})", X, Y);
    }
}