[%#
identity = lambda x: x
cast = lambda t: lambda x: "((%s)%s)" % (t, x)
round = lambda t: lambda x: "((%s)Math.Round(%s))" % (t, x)

_.types = ['int', 'long', 'float', 'double']

_.typesConfig = {}
for type in _.types:
    name = "Vector2%s" % {'int': "i", 'long': "L", 'float': "f", 'double': ""}[type]
    config = Params()
    
    config.name = name
    
    convType = {}
    
    convFrom = {}
    for t in _.types:
        convFrom[t] = identity
    
    normalizedSupport = False
    if _.T == "int":
        convType['int'] = "none"
        convType['long'] = "explicit"
        convType['float'] = "explicit"
        convType['double'] = "explicit"
        convFrom['long'] = cast(type)
        convFrom['float'] = round(type)
        convFrom['double'] = round(type)
    elif _.T == "long":
        convType['int'] = "implicit"
        convType['long'] = "none"
        convType['float'] = "explicit"
        convType['double'] = "explicit"
        convFrom['float'] = round(type)
        convFrom['double'] = round(type)
    elif _.T == "float":
        normalizedSupport = True
        convType['int'] = "implicit"
        convType['long'] = "implicit"
        convType['float'] = "none"
        convType['double'] = "explicit"
        convFrom['double'] = cast(type)
    elif _.T == "double":
        normalizedSupport = True
        convType['int'] = "implicit"
        convType['long'] = "implicit"
        convType['float'] = "implicit"
        convType['double'] = "none"
    
    config.normalizedSupport = normalizedSupport
    config.convType = convType
    config.convFrom = convFrom
    
    _.typesConfig[type] = config

_.config =  _.typesConfig[_.T]

_.name = _.config.name
#%]

public struct [#name#] : IEquatable<[#name#]>
{
    public [#T#] X 
    {
        get { return _x; }
    }

    public [#T#] Y 
    {
        get { return _y; }
    }
    
    private readonly [#T#] _x;
    private readonly [#T#] _y;

    public enum Axis
    {
        X = 0,
        Y = 1,
        Count = 2 // used in for loops
    }

    public [#T#] this[Axis axis]
    {
        get
        {
            switch (axis)
            {
                case Axis.X:
                    return _x;

                case Axis.Y:
                    return _y;

                default:
                    throw new IndexOutOfRangeException("Invalid 2D axis " + axis.ToString());
            }
        }
    }

    #region creation

    public [#name#]([#T#] x, [#T#] y)
    {
        _x = x;
        _y = y;
    }
    
[*# _.types ::
    public [#name#]([=# _.typesConfig[_item_].name #=] v)
    {
        _x = [=# _.config.convFrom[_item_]("v.X") #=];
        _y = [=# _.config.convFrom[_item_]("v.Y") #=];
    }
#*]

    public [#name#](OVector v)
    {
        ArgAssert.Equal(v.Dimension, "v.Dimension", 2, "2");

        _x = [=# _.config.convFrom['double']("v[0]") #=];
        _y = [=# _.config.convFrom['double']("v[1]") #=];
    }
    
[*# _.types ::
[?# _.config.convType[_item_] != "none" :?
    public static [=# _.config.convType[_item_] #=] operator [#name#]([=# _.typesConfig[_item_].name #=] v)
    {
        return new [#name#](v);
    }
#?]
#*]

    public static explicit operator [#name#](OVector v)
    {
        return new [#name#](v);
    }

    public static explicit operator OVector([#name#] v)
    {
        return new Vector(v._x, v._y);
    }
    
    #endregion

    #region equality

    public bool Equals([#name#] v)
    {
        return X == v.X && Y == v.Y;
    }

    public override bool Equals(object obj)
    {
        var v = obj as [#name#]?;

        if(!v.HasValue)
        {
            return false;
        }

        return Equals(v.Value);
    }

    public override int GetHashCode()
    {
        return X.GetHashCode() ^ Y.GetHashCode();
    }
    
    public static bool operator ==([#name#] v, [#name#] w)
    {
        return v.Equals(w);
    }

    public static bool operator !=([#name#] v, [#name#] w)
    {
        return !v.Equals(w);
    }

    #endregion

    #region norm

    public [#T#] Norm2
    {
        get { return _x * _x + _y * _y; }
    }
    
    public double Norm
    {
        get { return Math.Sqrt(Norm2); }
    }

    public static [#T#] Distance2([#name#] v, [#name#] w)
    {
        return (v - w).Norm2;
    }
    
    public static double Distance([#name#] v, [#name#] w)
    {
        return (v - w).Norm;
    }
    
[?#  _.config.normalizedSupport :?
    public [#name#] Normalized
    {
        get
        {
            var norm = this.Norm;

            if (norm < BasicMath.Epsilon)
            {
                return UnitX;
            }

            return this / [=# _.config.convFrom['double']("norm") #=];
        }
    }
#?]

    #endregion

    #region algebra

    public static [#name#] operator +([#name#] v)
    {
        return v;
    }

    public static [#name#] operator -([#name#] v)
    {
        return new [#name#](-v._x, -v._y);
    }

    public static [#name#] operator *([#name#] v, [#T#] a)
    {
        return new [#name#](v._x * a, v._y * a);
    }

    public static [#name#] operator *([#T#] a, [#name#] v)
    {
        return v * a;
    }

    public static [#name#] operator /([#name#] v, [#T#] a)
    {
        return new [#name#](v._x / a, v._y / a);
    }

    public static [#name#] operator +([#name#] v, [#name#] w)
    {
        return new [#name#](v._x + w._x, v._y + w._y);
    }

    public static [#name#] operator -([#name#] v, [#name#] w)
    {
        return new [#name#](v._x - w._x, v._y - w._y);
    }

    public static [#T#] operator *([#name#] v, [#name#] w)
    {
        return v._x * w._x + v._y * w._y;
    }

    public [#T#] Cross([#name#] v)
    {
        return _x * v._y - _y * v._x;
    }
    
    public static [#name#] Mul([#name#] v, [#name#] w)
    {
        return new [#name#](v.X * w.X, v.Y * w.Y);
    }

    #endregion

    #region static

    public static readonly [#name#] Zero = new [#name#](0, 0);
    public static readonly [#name#] UnitX = new [#name#](1, 0);
    public static readonly [#name#] UnitY = new [#name#](0, 1);

    public static [#name#] Unit(Axis axis)
    {
        switch (axis)
        {
            case Axis.X:
                return UnitX;

            case Axis.Y:
                return UnitY;

            default:
                throw new IndexOutOfRangeException("Invalid 2D axis " + axis.ToString());
        }
    }

    public static double Angle([#name#] v, [#name#] w)
    {
        var vwcos = v * w;
        var vwsin = v.Cross(w);

        return Math.Atan2(vwsin, vwcos);
    }

    #endregion

    public override string ToString()
    {
        return string.Format("({0}, {1})", X, Y);
    }
}